<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level JSON Reader</title>
</head>

<body>
    <div class="file-selectors">
        <label for="file">Choose a Level File:
            <input type="file" name="file" id="file" accept=".level">
        </label>
        <br>
        <label for="verified-file">Choose a Verified Level File:
            <input type="file" name="verified-file" id="verified-file" accept=".level">
        </label>
    </div>
    <button id="compare-button">Compare to Verified Data</button>

    <div id="console-output"></div>

    <script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.js"></script>
    <script type="text/javascript">
        let levelData = null;
        let verifiedData = null;
        let verifiedDataArray = []; // Array to store verified data entries

        document.getElementById('file').addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (file) {
                readLevelFile(file);
            }
        }, false);

        document.getElementById('verified-file').addEventListener("change", function (e) {
            const verifiedFile = e.target.files[0];
            if (verifiedFile) {
                readVerifiedLevelFile(verifiedFile);
            }
        }, false);
// Add this after your other event listeners
document.getElementById('compare-button').addEventListener("click", function () {
    compareDataPatterns();
}, false);

        function readLevelFile(file) {
            const reader = new FileReader();
            reader.onload = function () {
                const data = reader.result;
                protobuf.load("proto/level.proto", function (err, root) {
                    if (err) throw err;
                    const message = root.lookupType("COD.Level.Level");
                    const decoded = message.decode(new Uint8Array(data));
                    levelData = message.toObject(decoded);
                    console.log(levelData);
                    displayLevelInfo(levelData);
                   // compareDataPatterns();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function readVerifiedLevelFile(file) {
    const reader = new FileReader();
    reader.onload = function () {
        const data = reader.result;
        protobuf.load("proto/level.proto", function (err, root) {
            if (err) throw err;
            const message = root.lookupType("COD.Level.Level");
            const decoded = message.decode(new Uint8Array(data));
            const verifiedDataEntry = message.toObject(decoded);
            verifiedDataArray.push(verifiedDataEntry); // Store verified data entry in the array
            console.log(verifiedDataArray); 
            console.log(verifiedDataEntry); // Optional: log the updated array
        });
    };
    reader.readAsArrayBuffer(file);
}


        function displayLevelInfo(levelData) {
            const consoleOutput = document.getElementById('console-output');
            consoleOutput.innerHTML = "<pre>" + JSON.stringify(levelData, null, 4) + "</pre>";
        }
        function compareDataPatterns() {
    if (levelData && verifiedDataArray.length > 0) {
        const consoleOutput = document.getElementById('console-output');
        let resultsHTML = "<pre>Similarity Results:</pre>";
       const threshold =0.8
        for (let verifiedDataEntrys of verifiedDataArray) {
            const similarity = calculateSimilarity(levelData, verifiedDataEntry);
            const verificationResult = similarity >= threshold ? "Verified" : "Not Verified";
            resultsHTML += `<pre>Similarity: ${similarity.toFixed(2)}, Verification Result: ${verificationResult}</pre>`;
        }

        consoleOutput.innerHTML = resultsHTML;
    }
}


        function calculateSimilarity(obj1, obj2) {
            // Simple Jaccard index calculation for demonstration
            const set1 = new Set(Object.keys(obj1));
            const set2 = new Set(Object.keys(obj2));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }
    </script>
</body>

</html>
