<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level JSON Reader</title>
</head>

<body>
    <div class="file-selectors">
        <label for="file">Choose a Level File:
            <input type="file" name="file" id="file" accept=".level">
        </label>
        <br>
        <label for="verified-file">Choose a Verified Level File:
            <input type="file" name="verified-file" id="verified-file" accept=".level">
        </label>
    </div>
    <button id="compare-button">Compare to Verified Data</button>

    <div id="console-output"></div>

    <script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.js"></script>
    <script type="text/javascript">
        let levelData = null;
        let verifiedData = null;
        let verifiedDataArray = []; // Array to store verified data entries

        document.getElementById('file').addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (file) {
                readLevelFile(file);
            }
        }, false);

        document.getElementById('verified-file').addEventListener("change", function (e) {
            const verifiedFile = e.target.files[0];
            if (verifiedFile) {
                readVerifiedLevelFile(verifiedFile);
            }
        }, false);
// Add this after your other event listeners
document.getElementById('compare-button').addEventListener("click", function () {
    compareDataPatterns();
}, false);

        function readLevelFile(file) {
            const reader = new FileReader();
            reader.onload = function () {
                const data = reader.result;
                protobuf.load("proto/level.proto", function (err, root) {
                    if (err) throw err;
                    const message = root.lookupType("COD.Level.Level");
                    const decoded = message.decode(new Uint8Array(data));
                    levelData = message.toObject(decoded);
                    console.log(levelData);
                    displayLevelInfo(levelData);
                   // compareDataPatterns();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function readVerifiedLevelFile(file) {
    const reader = new FileReader();
    reader.onload = function () {
        const data = reader.result;
        protobuf.load("proto/level.proto", function (err, root) {
            if (err) throw err;
            const message = root.lookupType("COD.Level.Level");
            const decoded = message.decode(new Uint8Array(data));
            const verifiedDataEntry = message.toObject(decoded);
            verifiedDataArray.push(verifiedDataEntry); // Store verified data entry in the array
            console.log(verifiedDataArray); 
            console.log(verifiedDataEntry); // Optional: log the updated array
        });
    };
    reader.readAsArrayBuffer(file);
}


        function displayLevelInfo(levelData) {
            const consoleOutput = document.getElementById('console-output');
            consoleOutput.innerHTML = "<pre>" + JSON.stringify(levelData, null, 4) + "</pre>";
        }
        function compareDataPatterns() {
    if (levelData && verifiedDataArray.length > 0) {
        const consoleOutput = document.getElementById('console-output');
        let resultsHTML = "<pre>Similarity Results:</pre>";
       const threshold =0.8
        for (let verifiedDataEntrys of verifiedDataArray) {
            const similarity = calculateSimilarity(levelData, verifiedDataEntrys);
            const verificationResult = similarity >= threshold ? "Verified" : "Not Verified";
            resultsHTML += `<pre>Similarity: ${similarity.toFixed(2)}, Verification Result: ${verificationResult}</pre>`;
        }

        consoleOutput.innerHTML = resultsHTML;
    }
}

function calculateCosineSimilarity(obj1, obj2) {
    const keys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);

    const vector1 = [];
    const vector2 = [];

    for (const key of keys) {
        const value1 = obj1[key] || 0;
        const value2 = obj2[key] || 0;
        vector1.push(value1);
        vector2.push(value2);
    }

    const dotProduct = vector1.reduce((sum, value1, index) => sum + value1 * vector2[index], 0);
    const magnitude1 = Math.sqrt(vector1.reduce((sum, value) => sum + value * value, 0));
    const magnitude2 = Math.sqrt(vector2.reduce((sum, value) => sum + value * value, 0));

    if (magnitude1 === 0 || magnitude2 === 0) {
        return 0; // Avoid division by zero
    }

    return dotProduct / (magnitude1 * magnitude2);
}

    </script>
</body>

</html>
