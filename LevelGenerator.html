<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level JSON Reader</title>
</head>

<body>
    <div class="file-selectors">
        <label for="file">Choose a Level File:
            <input type="file" name="file" id="file" accept=".level">
        </label>
        <br>
        <label for="verified-file">Choose a Verified Level File:
            <input type="file" name="verified-file" id="verified-file" accept=".level">
        </label>
    </div>
    <button id="compare-button">Compare to Verified Data</button>

    <div id="console-output"></div>

    <script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.js"></script>
    <script type="text/javascript">
        let levelData = null;
        let verifiedData = null;
        let verifiedDataArray = []; // Array to store verified data entries

        document.getElementById('file').addEventListener("change", function (e) {
            const file = e.target.files[0];
            if (file) {
                readLevelFile(file);
            }
        }, false);

        document.getElementById('verified-file').addEventListener("change", function (e) {
            const verifiedFile = e.target.files[0];
            if (verifiedFile) {
                readVerifiedLevelFile(verifiedFile);
            }
        }, false);
// Add this after your other event listeners
document.getElementById('compare-button').addEventListener("click", function () {
    compareDataPatterns();
}, false);

        function readLevelFile(file) {
            const reader = new FileReader();
            reader.onload = function () {
                const data = reader.result;
                protobuf.load("proto/level.proto", function (err, root) {
                    if (err) throw err;
                    const message = root.lookupType("COD.Level.Level");
                    const decoded = message.decode(new Uint8Array(data));
                    levelData = message.toObject(decoded);
                    console.log(levelData);
                    displayLevelInfo(levelData);
                   // compareDataPatterns();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function readVerifiedLevelFile(file) {
    const reader = new FileReader();
    reader.onload = function () {
        const data = reader.result;
        protobuf.load("proto/level.proto", function (err, root) {
            if (err) throw err;
            const message = root.lookupType("COD.Level.Level");
            const decoded = message.decode(new Uint8Array(data));
            const verifiedDataEntry = message.toObject(decoded);
            verifiedDataArray.push(verifiedDataEntry); // Store verified data entry in the array
            console.log(verifiedDataArray); 
            console.log(verifiedDataEntry); // Optional: log the updated array
        });
    };
    reader.readAsArrayBuffer(file);
}


        function displayLevelInfo(levelData) {
            const consoleOutput = document.getElementById('console-output');
            consoleOutput.innerHTML = "<pre>" + JSON.stringify(levelData, null, 4) + "</pre>";
        }
        function compareDataPatterns() {
    if (levelData && verifiedDataArray.length > 0) {
        const consoleOutput = document.getElementById('console-output');
        let resultsHTML = "<pre>Similarity Results:</pre>";
       const threshold =0.8
        for (let verifiedDataEntrys of verifiedDataArray) {
            const similarity = calculateSimilarity(levelData, verifiedDataEntrys);
            const verificationResult = similarity >= threshold ? "Verified" : "Not Verified";
            resultsHTML += `<pre>Similarity: ${similarity.toFixed(2)}, Verification Result: ${verificationResult}</pre>`;
        }

        consoleOutput.innerHTML = resultsHTML;
    }
}


function calculateSimilarity(obj1, obj2) {
    // Calculate the dot product of values for common keys
    let dotProduct = 0;
    let magnitude1 = 0;
    let magnitude2 = 0;

    for (const key of Object.keys(obj1)) {
        if (obj2.hasOwnProperty(key)) {
            dotProduct += obj1[key] * obj2[key];
        }
        magnitude1 += obj1[key] * obj1[key];
    }

    for (const value of Object.values(obj2)) {
        magnitude2 += value * value;
    }

    if (magnitude1 === 0 || magnitude2 === 0) {
        return 0; // Handle cases with zero magnitudes
    }

    const similarity = dotProduct / (Math.sqrt(magnitude1) * Math.sqrt(magnitude2));
    return similarity;
}

    </script>
</body>

</html>
